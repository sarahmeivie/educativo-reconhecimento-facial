<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <title>Gaze + Regiões + Emoções (JSON %)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { height: 100%; margin: 0; }
    body { font-family: Arial, sans-serif; text-align: center; overflow: hidden; background:#f7f7f9; }
    header { padding: 12px 16px; background:#fff; border-bottom:1px solid #e9e9ef; display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:center; }
    h1 { margin: 0 12px 0 0; font-size: 18px; }
    .btn { padding: 9px 14px; cursor: pointer; border: none; border-radius: 8px; background:#2b6fff; color:#fff; font-weight:600; }
    .btn.secondary { background:#555; }
    .btn.ghost { background:#fff; color:#2b6fff; border:1px solid #2b6fff; }
    .btn.warn { background:#b45309; }
    #status { width:100%; font-size: 14px; color:#333; min-height: 22px; }
    #wrap { height: calc(100% - 126px); display:flex; align-items:center; justify-content:center; color:#777; user-select: none; }

    .calibration-point {
      position: fixed; width: 22px; height: 22px; background: red; border-radius: 50%;
      transform: translate(-50%, -50%); display: none; z-index: 30;
      box-shadow: 0 0 0 4px rgba(255,0,0,.15);
    }
    .calibration-ring {
      position: fixed; width: 46px; height: 46px; border: 2px dashed rgba(255,0,0,.5);
      border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 29;
    }
    .gaze-point {
      position: fixed; width: 10px; height: 10px; background: #2563eb; border-radius: 50%;
      transform: translate(-50%, -50%); z-index: 28; display: none; box-shadow: 0 0 0 4px rgba(37,99,235,.2);
    }
    .region { position: fixed; top: 0; height: 100%; z-index: 10; pointer-events: none;
      border-left: 1px dashed rgba(0,0,0,.1); border-right:1px dashed rgba(0,0,0,.1);
      display:flex; align-items:flex-start; justify-content:center; }
    .region .label { margin-top: 8px; padding: 4px 8px; border-radius: 6px; font-size: 12px; font-weight:700; color:#111; background: rgba(255,255,255,.85); border:1px solid rgba(0,0,0,.08); }
    .region.left  { background: rgba(255,0,0,.05); }
    .region.center{ background: rgba(0,255,0,.04); }
    .region.right { background: rgba(0,0,255,.05); }
    .region.active { outline: 2px solid rgba(0,0,0,.25); outline-offset: -2px; }

    #hud, #hud2 {
      position: fixed; right: 12px; background: rgba(0,0,0,.65); color:#fff; padding: 8px 10px; border-radius: 8px; font-size: 12px; z-index: 40;
    }
    #hud { bottom: 12px; }
    #hud2 { bottom: 72px; }

    #panel {
      position: fixed; left: 12px; bottom: 12px; z-index: 40; background: rgba(255,255,255,.95);
      border:1px solid #e5e7eb; border-radius: 10px; padding: 10px 12px; font-size: 12px; color:#111;
      display: grid; grid-template-columns: auto auto; gap:6px 8px;
    }
    #panel input[type="number"] { width: 72px; padding: 2px 6px; }
    #panel .row { grid-column: 1 / -1; }

    #jsonBox {
      position: fixed; left: 12px; top: 12px; width: 360px; max-width: 92vw; max-height: 38vh;
      background: #0b1020; color:#d1e6ff; border:1px solid #1c274b; border-radius: 10px; padding: 10px; text-align:left; overflow:auto; font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; z-index: 50;
    }
    #jsonBox pre { margin: 0; white-space: pre-wrap; word-break: break-word; }
    #jsonActions { display:flex; gap:6px; margin-top:6px; }
    #jsonActions .btn { padding: 6px 10px; font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>Gaze + 3 Regiões + Emoções → JSON (%)</h1>
    <button class="btn" id="btnCalibrate">Calibrar</button>
    <button class="btn secondary" id="btnRecalibrate">Recalibrar</button>
    <button class="btn ghost" id="btnTogglePreview">Mostrar vídeo</button>
    <button class="btn warn" id="btnExportCSV">Exportar CSV (regiões)</button>
    <button class="btn ghost" id="btnExportJSON">Exportar JSON (%)</button>
    <button class="btn ghost" id="btnAnalyzeAI">Analisar com IA</button>
    <div id="status"></div>
  </header>

  <div id="jsonBox">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
      <strong>Saída JSON (ao vivo)</strong>
      <div id="jsonActions">
        <button class="btn ghost" id="btnCopyJSON">Copiar</button>
        <button class="btn ghost" id="btnToggleJSON">Ocultar</button>
      </div>
    </div>
    <pre id="jsonOut">{}</pre>
  </div>

  <div id="wrap">Clique em “Calibrar”, olhe o alvo e clique 5× em cada ponto.</div>

  <div id="calibPoint" class="calibration-point"></div>
  <div id="calibRing" class="calibration-ring"></div>
  <div id="gazeDot" class="gaze-point"></div>

  <div id="regionLeft"  class="region left"><div class="label">ESQ</div></div>
  <div id="regionCenter"class="region center"><div class="label">CENTRO (jogo)</div></div>
  <div id="regionRight" class="region right"><div class="label">DIR</div></div>

  <div id="hud">
    Amostras: <span id="samples">0</span> • Ponto: <span id="pidx">–</span>/<span id="ptotal">–</span><br/>
    Região atual: <b><span id="curRegion">–</span></b> • Dwell: <span id="curDwell">0</span> ms<br/>
    T(ESQ): <span id="tLeft">0</span> ms • T(CENTRO): <span id="tCenter">0</span> ms • T(DIR): <span id="tRight">0</span> ms
  </div>

  <div id="hud2">
    Emoção atual: <b><span id="curEmotion">–</span></b><br/>
    T(Feliz): <span id="eHappy">0</span> ms • T(Triste): <span id="eSad">0</span> ms • T(Tédio): <span id="eBored">0</span> ms • T(Neutro): <span id="eNeutral">0</span> ms
  </div>

  <div id="panel">
    <div>Centro (% largura):</div>
    <div><input id="inpCenterPct" type="number" min="20" max="80" step="1" value="50"></div>
    <div>Dwell p/ troca (ms):</div>
    <div><input id="inpDwellMs" type="number" min="50" step="10" value="250"></div>
    <div>Neutro→Tédio (ms seguidos):</div>
    <div><input id="inpBoredMs" type="number" min="1000" step="500" value="5000"></div>
  </div>
<!-- Libs -->
<script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>

<script>
  // =================== CONFIG BÁSICA ===================
  const CLICKS_PER_POINT = 5;
  const EMA_ALPHA = 0.35;
  const SHOW_PRED_POINTS = false;

  // =================== ESTADO GERAL ===================
  let calibrationRunning = false;
  let points = [];
  let pIndex = 0;
  let clickCount = 0;
  let emaX = null, emaY = null;
  let showPreview = false;

  // Regiões
  let centerPct = 0.50;
  let dwellThresholdMs = 250;

  let curRegion = null, candRegion = null, candSince = 0;
  let lastTs = performance.now();
  const dwellTotals = { LEFT:0, CENTER:0, RIGHT:0 };
  const eventLog = []; // mudanças de região

  // Emoções
  const EMOT = { HAPPY: 'FELIZ', SAD: 'TRISTE', BORED: 'TÉDIO', NEUTRAL: 'NEUTRO' };
  let curEmotion = null;
  const emotionTotals = { FELIZ:0, TRISTE:0, TÉDIO:0, NEUTRO:0 };
  let neutralSince = 0;
  let boredThresholdMs = 5000;

  // JSON saída
  function getPercent(ms, total) { return total > 0 ? (ms / total * 100) : 0; }
  function getJSONSummary() {
    const totalRegionMs = dwellTotals.LEFT + dwellTotals.CENTER + dwellTotals.RIGHT;
    const totalEmotionMs = emotionTotals['FELIZ'] + emotionTotals['TRISTE'] + emotionTotals['TÉDIO'] + emotionTotals['NEUTRO'];
    return {
      regions: {
        leftPct:   +getPercent(dwellTotals.LEFT, totalRegionMs).toFixed(2),
        centerPct: +getPercent(dwellTotals.CENTER, totalRegionMs).toFixed(2),
        rightPct:  +getPercent(dwellTotals.RIGHT, totalRegionMs).toFixed(2),
        totalMs:   Math.round(totalRegionMs)
      },
      emotions: {
        happyPct:  +getPercent(emotionTotals['FELIZ'],  totalEmotionMs).toFixed(2),
        sadPct:    +getPercent(emotionTotals['TRISTE'], totalEmotionMs).toFixed(2),
        boredPct:  +getPercent(emotionTotals['TÉDIO'],  totalEmotionMs).toFixed(2),
        neutralPct:+getPercent(emotionTotals['NEUTRO'], totalEmotionMs).toFixed(2),
        totalMs:   Math.round(totalEmotionMs)
      },
      current: { region: curRegion ?? null, emotion: curEmotion ?? null },
      timestamps: { updatedAt: new Date().toISOString() }
    };
  }

  // =================== ELEMENTOS ===================
  const statusEl = document.getElementById('status');
  const btnCalib = document.getElementById('btnCalibrate');
  const btnRecalib = document.getElementById('btnRecalibrate');
  const btnTogglePreview = document.getElementById('btnTogglePreview');
  const btnExportCSV = document.getElementById('btnExportCSV');
  const btnExportJSON = document.getElementById('btnExportJSON');
  const btnCopyJSON = document.getElementById('btnCopyJSON');
  const btnToggleJSON = document.getElementById('btnToggleJSON');
  const btnAnalyzeAI = document.getElementById('btnAnalyzeAI');

  const calibPoint = document.getElementById('calibPoint');
  const calibRing  = document.getElementById('calibRing');
  const gazeDot    = document.getElementById('gazeDot');

  const samplesEl  = document.getElementById('samples');
  const pidxEl     = document.getElementById('pidx');
  const ptotalEl   = document.getElementById('ptotal');
  const curRegionEl= document.getElementById('curRegion');
  const curDwellEl = document.getElementById('curDwell');
  const tLeftEl    = document.getElementById('tLeft');
  const tCenterEl  = document.getElementById('tCenter');
  const tRightEl   = document.getElementById('tRight');

  const curEmotionEl = document.getElementById('curEmotion');
  const eHappyEl  = document.getElementById('eHappy');
  const eSadEl    = document.getElementById('eSad');
  const eBoredEl  = document.getElementById('eBored');
  const eNeutralEl= document.getElementById('eNeutral');

  const regionLeft  = document.getElementById('regionLeft');
  const regionCenter= document.getElementById('regionCenter');
  const regionRight = document.getElementById('regionRight');

  const inpCenterPct= document.getElementById('inpCenterPct');
  const inpDwellMs  = document.getElementById('inpDwellMs');
  const inpBoredMs  = document.getElementById('inpBoredMs');

  const jsonOut = document.getElementById('jsonOut');
  const jsonBox = document.getElementById('jsonBox');

  // =================== FUNÇÕES AUXILIARES ===================
  function setStatus(msg) { statusEl.textContent = msg; }
  function layoutRegions() {
    const w = window.innerWidth;
    const centerW = Math.max(0.2, Math.min(0.8, centerPct)) * w;
    const sideW = (w - centerW) / 2;
    regionLeft.style.left = '0px'; regionLeft.style.width = sideW + 'px';
    regionCenter.style.left = sideW + 'px'; regionCenter.style.width = centerW + 'px';
    regionRight.style.left = (sideW + centerW) + 'px'; regionRight.style.width = sideW + 'px';
  }
  function whichRegion(x) {
    const w = window.innerWidth;
    const centerW = Math.max(0.2, Math.min(0.8, centerPct)) * w;
    const sideW = (w - centerW) / 2;
    if (x < sideW) return 'LEFT';
    if (x > sideW + centerW) return 'RIGHT';
    return 'CENTER';
  }
  function setActiveRegionUI(regionId) {
    regionLeft.classList.toggle('active', regionId==='LEFT');
    regionCenter.classList.toggle('active', regionId==='CENTER');
    regionRight.classList.toggle('active', regionId==='RIGHT');
    curRegionEl.textContent = regionId ?? '–';
  }
  function updateRegionHUD() {
    tLeftEl.textContent   = dwellTotals.LEFT.toFixed(0);
    tCenterEl.textContent = dwellTotals.CENTER.toFixed(0);
    tRightEl.textContent  = dwellTotals.RIGHT.toFixed(0);
  }
  function updateEmotionHUD() {
    eHappyEl.textContent   = emotionTotals['FELIZ'].toFixed(0);
    eSadEl.textContent     = emotionTotals['TRISTE'].toFixed(0);
    eBoredEl.textContent   = emotionTotals['TÉDIO'].toFixed(0);
    eNeutralEl.textContent = emotionTotals['NEUTRO'].toFixed(0);
    curEmotionEl.textContent = curEmotion ?? '–';
  }
  function logRegionChange(newRegion, x, y) {
    eventLog.push({ ts: Date.now(), region: newRegion, x: Math.round(x), y: Math.round(y) });
  }
  function exportCSV() {
    const rows = [
      ['timestamp_ms','iso_datetime','region','x','y'],
      ...eventLog.map(e => [e.ts, new Date(e.ts).toISOString(), e.region, e.x, e.y])
    ];
    const csv = rows.map(r => r.join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'gaze_region_events.csv';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }
  function exportJSON() {
    const obj = getJSONSummary();
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'gaze_summary.json';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }
  function copyJSON() {
    const obj = getJSONSummary();
    navigator.clipboard.writeText(JSON.stringify(obj, null, 2)).then(()=> {
      setStatus('JSON copiado para a área de transferência.');
    }).catch(()=>{ setStatus('Não foi possível copiar o JSON.'); });
  }
  function refreshJSONBox() {
    jsonOut.textContent = JSON.stringify(getJSONSummary(), null, 2);
  }

// =================== CALIBRAÇÃO ===================
function makeGridPoints() {
      const w = window.innerWidth, h = window.innerHeight;
      return [
        {x: 0.10*w, y: 0.10*h}, {x: 0.50*w, y: 0.10*h}, {x: 0.90*w, y: 0.10*h},
        {x: 0.10*w, y: 0.50*h}, {x: 0.50*w, y: 0.50*h}, {x: 0.90*w, y: 0.50*h},
        {x: 0.10*w, y: 0.90*h}, {x: 0.50*w, y: 0.90*h}, {x: 0.90*w, y: 0.90*h},
      ];
    }
    function showTarget(x, y) {
      calibPoint.style.left = x + 'px'; calibPoint.style.top = y + 'px';
      calibRing.style.left = x + 'px';  calibRing.style.top = y + 'px';
      calibPoint.style.display = 'block'; calibRing.style.display = 'block';
    }
    function hideTarget() { calibPoint.style.display = 'none'; calibRing.style.display = 'none'; }

    async function startCalibration() {
      if (calibrationRunning) return;
      calibrationRunning = true;

      emaX = emaY = null;
      points = makeGridPoints();
      pIndex = 0; ptotalEl.textContent = points.length; samplesEl.textContent = '0'; pidxEl.textContent = '1'; clickCount = 0;

      gazeDot.style.display = 'none';
      webgazer.showPredictionPoints(false);
      setStatus('Calibração: olhe e clique 5× em cada alvo.');

      window.addEventListener('click', onCalibClick, true);
      nextPoint();
    }
    function onCalibClick() {
      if (!calibrationRunning) return;
      if (calibPoint.style.display !== 'block') return;
      const p = points[pIndex];
      webgazer.recordScreenPosition(p.x, p.y, 'click');
      clickCount++; samplesEl.textContent = String(parseInt(samplesEl.textContent) + 1);
      if (clickCount >= CLICKS_PER_POINT) {
        pIndex++; clickCount = 0;
        if (pIndex < points.length) { pidxEl.textContent = String(pIndex + 1); nextPoint(); }
        else { finishCalibration(); }
      }
    }
    function nextPoint() { const p = points[pIndex]; showTarget(p.x, p.y); }
    async function finishCalibration() {
      window.removeEventListener('click', onCalibClick, true);
      hideTarget(); setStatus('Treinando modelo…');
      try { await webgazer.train(); } catch (e) { console.error('train():', e); }
      setStatus('Calibração concluída!'); gazeDot.style.display = 'block';
      webgazer.showPredictionPoints(SHOW_PRED_POINTS);
      calibrationRunning = false;
    }
    async function resetAndRecalibrate() {
      try { await webgazer.clearData(); } catch(e) {}
      curRegion = candRegion = null; candSince = 0;
      dwellTotals.LEFT = dwellTotals.CENTER = dwellTotals.RIGHT = 0;
      setActiveRegionUI(null); updateRegionHUD(); eventLog.length = 0;

      curEmotion = null; neutralSince = 0;
      emotionTotals['FELIZ'] = emotionTotals['TRISTE'] = emotionTotals['TÉDIO'] = emotionTotals['NEUTRO'] = 0;
      updateEmotionHUD();

      setStatus('Dados limpos. Inicie nova calibração.');
      startCalibration();
    }

    // =================== EMOÇÕES ===================
    let faceapiReady = false, useFaceAPI = false;
    async function initFaceAPI() {
      try {
        const modelURL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
        await faceapi.nets.tinyFaceDetector.loadFromUri(modelURL);
        await faceapi.nets.faceExpressionNet.loadFromUri(modelURL);
        useFaceAPI = true; faceapiReady = true;
        setStatus('Modelos de emoção carregados.');
      } catch (e) {
        console.warn('face-api: não carregou modelos.', e);
        useFaceAPI = false; faceapiReady = false;
        setStatus('Emoções: modo heurístico.');
      }
    }

    async function emotionLoop() {
      const video = webgazer.getVideoElement ? webgazer.getVideoElement() : null;
      if (video && useFaceAPI && faceapiReady) {
        try {
          const det = await faceapi.detectSingleFace(video, new faceapi.TinyFaceDetectorOptions({ inputSize: 160, scoreThreshold: 0.5 })).withFaceExpressions();
          if (det && det.expressions) {
            const ex = det.expressions;
            const isHappy = (ex.happy || 0) >= 0.6;
            const isSad   = (ex.sad || 0)   >= 0.5;
            const isNeutral = (ex.neutral || 0) >= 0.6 && !isHappy && !isSad;

            let nextEmotion = EMOT.NEUTRO;
            if (isHappy) nextEmotion = EMOT.HAPPY;
            else if (isSad) nextEmotion = EMOT.SAD;
            else if (isNeutral) nextEmotion = EMOT.NEUTRO;

            const now = performance.now();
            if (nextEmotion === EMOT.NEUTRO) {
              if (neutralSince === 0) neutralSince = now;
              if ((now - neutralSince) >= boredThresholdMs) nextEmotion = EMOT.BORED;
            } else {
              neutralSince = 0;
            }
            curEmotion = nextEmotion;
            updateEmotionHUD();
          }
        } catch (e) {
          useFaceAPI = false;
        }
      }
      setTimeout(emotionLoop, 200);
    }

    // =================== INICIALIZAÇÃO ===================
    window.addEventListener('load', async () => {
      layoutRegions();
      webgazer
        .setRegression('ridge')
        .setGazeListener((data) => {
          if (!data) return;
          const now = performance.now();
          const delta = now - lastTs;
          lastTs = now;

          if (emaX === null) { emaX = data.x; emaY = data.y; }
          else { emaX = EMA_ALPHA * data.x + (1 - EMA_ALPHA) * emaX;
                emaY = EMA_ALPHA * data.y + (1 - EMA_ALPHA) * emaY; }

          gazeDot.style.left = emaX + 'px'; gazeDot.style.top  = emaY + 'px';

          if (curRegion) { dwellTotals[curRegion] += delta; updateRegionHUD(); }

          const rNow = whichRegion(emaX);
          if (candRegion !== rNow) { candRegion = rNow; candSince = now; }
          curDwellEl.textContent = Math.max(0, Math.round(now - candSince));
          if (curRegion !== candRegion && (now - candSince) >= dwellThresholdMs) {
            curRegion = candRegion; setActiveRegionUI(curRegion); logRegionChange(curRegion, emaX, emaY);
          }

          if (curEmotion) {
            emotionTotals[curEmotion] += delta;
            updateEmotionHUD();
          }

          refreshJSONBox();
        });

      webgazer.showVideo(false);
      webgazer.showFaceOverlay(false);
      webgazer.showFaceFeedbackBox(false);
      webgazer.showPredictionPoints(false);

      try {
        await webgazer.begin();
        setStatus('Clique em “Calibrar” e siga as instruções.');
      } catch (err) {
        console.error(err);
        setStatus('Erro ao iniciar a câmera. Verifique permissões/HTTPS.');
        alert('Erro ao acessar a câmera. Verifique permissões e HTTPS.');
      }

      initFaceAPI().then(() => emotionLoop());
    });

    // =================== FUNÇÃO IA ===================
    async function analisarComIA() {
      const resumo = getJSONSummary();
      const prompt = `
      Analise os seguintes dados de rastreamento ocular:

      ${JSON.stringify(resumo, null, 2)}

      Explique:
      - Distribuição do olhar (esq/centro/dir).
      - Se há foco ou distração.
      - Possíveis interpretações cognitivas.
      - Recomendações práticas.
      `;

      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer AIzaSyBeg0CiFm60xqzJ-xdyI7w5-09jUBvoPGs" // 👉 coloque sua chave aqui
          },
          body: JSON.stringify({
            model: "gpt-4o-mini",
            messages: [{ role: "user", content: prompt }]
          })
        });

        const data = await response.json();
        const output = data.choices?.[0]?.message?.content || "Sem resposta da IA.";
        alert("📊 Análise da IA:\n\n" + output);
      } catch (err) {
        console.error(err);
        alert("Erro ao conectar com a IA.");
      }
    }

    // =================== EVENTOS UI ===================
    btnCalib.addEventListener('click', startCalibration);
    btnRecalib.addEventListener('click', resetAndRecalibrate);
    btnTogglePreview.addEventListener('click', () => {
      showPreview = !showPreview;
      webgazer.showVideo(showPreview);
      webgazer.showFaceOverlay(showPreview);
      webgazer.showFaceFeedbackBox(showPreview);
      btnTogglePreview.textContent = showPreview ? 'Ocultar vídeo' : 'Mostrar vídeo';
    });
    btnExportCSV.addEventListener('click', exportCSV);
    btnExportJSON.addEventListener('click', exportJSON);
    btnCopyJSON.addEventListener('click', copyJSON);
    btnToggleJSON.addEventListener('click', () => {
      const on = jsonBox.style.display !== 'none';
      jsonBox.style.display = on ? 'none' : 'block';
      btnToggleJSON.textContent = on ? 'Mostrar' : 'Ocultar';
    });
    btnAnalyzeAI.addEventListener('click', analisarComIA);

    window.addEventListener('resize', () => { layoutRegions(); });
    inpCenterPct.addEventListener('change', () => { centerPct = parseFloat(inpCenterPct.value)/100; layoutRegions(); });
    inpDwellMs.addEventListener('change', () => { dwellThresholdMs = Math.max(50, parseInt(inpDwellMs.value,10)||250); });
    inpBoredMs.addEventListener('change', () => { boredThresholdMs = Math.max(1000, parseInt(inpBoredMs.value,10)||5000); });
  </script>
</body>
</html>